var defaultVertexShader = 'attribute vec3 a_position;\nuniform mat4 u_modelViewProjectMatrix;\n\n#ifdef VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\n\n#ifdef MORPH_TARGETS\n  #if MORPH_TARGETS_COUNT > 0\n    attribute vec3 a_position0;\n  #endif\n  #if MORPH_TARGETS_COUNT > 1\n    attribute vec3 a_position1;\n  #endif\n  #if MORPH_TARGETS_COUNT > 2\n    attribute vec3 a_position2;\n  #endif\n  #if MORPH_TARGETS_COUNT > 3\n    attribute vec3 a_position3;\n  #endif\n  uniform float u_weights[MORPH_TARGETS_COUNT];\n#endif\n\n#ifdef SKIN\n  attribute vec4 a_joint;\n  attribute vec4 a_weight;\n  uniform mat4 u_jointMatrix[SKIN_JOINTS_COUNT];\n#endif\n\n#if (defined(DIFFUSE_MAP) && defined(DIFFUSE_CUBE_MAP)) || (defined(LIGHT) || defined(ENV_MAP))\n  attribute vec3 a_normal;\n  #ifdef MORPH_TARGETS\n    #if MORPH_TARGETS_COUNT > 0\n      attribute vec3 a_normal0;\n    #endif\n    #if MORPH_TARGETS_COUNT > 1\n      attribute vec3 a_normal1;\n    #endif\n    #if MORPH_TARGETS_COUNT > 2\n      attribute vec3 a_normal2;\n    #endif\n    #if MORPH_TARGETS_COUNT > 3\n      attribute vec3 a_normal3;\n    #endif\n  #endif\n#endif\n\n#if defined(LIGHT) && defined(NORMAL_MAP)\n  attribute vec3 a_tangent;\n  #ifdef MORPH_TARGETS\n    #if MORPH_TARGETS_COUNT > 0\n      attribute vec3 a_tangent0;\n    #endif\n    #if MORPH_TARGETS_COUNT > 1\n      attribute vec3 a_tangent1;\n    #endif\n    #if MORPH_TARGETS_COUNT > 2\n      attribute vec3 a_tangent2;\n    #endif\n    #if MORPH_TARGETS_COUNT > 3\n      attribute vec3 a_tangent3;\n    #endif\n  #endif\n#endif\n\n#if (defined(DIFFUSE_MAP) && !defined(DIFFUSE_CUBE_MAP)) || (defined(LIGHT) && defined(NORMAL_MAP))\n  attribute vec2 a_uv;\n  uniform vec2 u_textureScale;\n  varying vec2 v_uv;\n#endif\n\n#if defined(DIFFUSE_MAP) && defined(DIFFUSE_CUBE_MAP)\n  uniform mat3 u_normalMatrix;\n  varying vec3 v_normal;\n#endif\n\n#if (defined(LIGHT) && !defined(NORMAL_MAP)) || defined(ENV_MAP)\n  varying vec3 v_normalView;\n#endif\n\n#ifdef ENV_MAP\n  uniform mat4 u_viewMatrix;\n  varying vec4 v_viewPosition;\n#endif\n\n#if defined(LIGHT) || defined(ENV_MAP)\n  uniform mat3 u_normalViewMatrix;\n#endif\n\n#ifdef LIGHT\n  uniform mat4 u_modelViewMatrix;\n  uniform vec3 u_lightPosition;\n  varying vec3 v_lightDirection;\n  varying vec3 v_eyeDirection;\n#endif\n\n#ifdef WIREFRAME\n  attribute vec3 a_barycentric;\n  varying vec3 v_barycentric;\n#endif\n\n#ifdef CLIPPLANE\n  uniform mat4 u_modelMatrix;\n  varying vec4 v_position;\n#endif\n\nvoid main () {\n  vec3 position = a_position;\n\n  #ifdef MORPH_TARGETS\n    #if MORPH_TARGETS_COUNT > 0\n      position += a_position0 * u_weights[0];\n    #endif\n    #if MORPH_TARGETS_COUNT > 1\n      position += a_position1 * u_weights[1];\n    #endif\n    #if MORPH_TARGETS_COUNT > 2\n      position += a_position2 * u_weights[2];\n    #endif\n    #if MORPH_TARGETS_COUNT > 3\n      position += a_position3 * u_weights[3];\n    #endif\n  #endif\n\n  vec4 finalPosition = vec4(position, 1.0);\n\n  #ifdef SKIN\n    mat4 skinMat =\n      a_weight.x * u_jointMatrix[int(a_joint.x)] +\n      a_weight.y * u_jointMatrix[int(a_joint.y)] +\n      a_weight.z * u_jointMatrix[int(a_joint.z)] +\n      a_weight.w * u_jointMatrix[int(a_joint.w)];\n    finalPosition = skinMat * finalPosition;\n  #endif\n\n  #if (defined(DIFFUSE_MAP) && defined(DIFFUSE_CUBE_MAP)) || (defined(LIGHT) || defined(ENV_MAP))\n    vec3 finalNormal = a_normal;\n    #ifdef MORPH_TARGETS\n      #if MORPH_TARGETS_COUNT > 0\n        finalNormal += a_normal0 * u_weights[0];\n      #endif\n      #if MORPH_TARGETS_COUNT > 1\n        finalNormal += a_normal1 * u_weights[1];\n      #endif\n      #if MORPH_TARGETS_COUNT > 2\n        finalNormal += a_normal2 * u_weights[2];\n      #endif\n      #if MORPH_TARGETS_COUNT > 3\n        finalNormal += a_normal3 * u_weights[3];\n      #endif\n    #endif\n  #endif\n\n  #if defined(LIGHT) && defined(NORMAL_MAP)\n    vec3 finalTangent = a_tangent;\n    #ifdef MORPH_TARGETS\n      #if MORPH_TARGETS_COUNT > 0\n        finalTangent += a_tangent0 * u_weights[0];\n      #endif\n      #if MORPH_TARGETS_COUNT > 1\n        finalTangent += a_tangent1 * u_weights[1];\n      #endif\n      #if MORPH_TARGETS_COUNT > 2\n        finalTangent += a_tangent2 * u_weights[2];\n      #endif\n      #if MORPH_TARGETS_COUNT > 3\n        finalTangent += a_tangent3 * u_weights[3];\n      #endif\n    #endif\n  #endif\n\n  #if !defined(WIREFRAME) || !defined(WIREFRAME_ONLY)\n    #if defined(DIFFUSE_MAP) && defined(DIFFUSE_CUBE_MAP)\n      v_normal = u_normalMatrix * finalNormal;\n    #endif\n\n    #if (defined(DIFFUSE_MAP) && !defined(DIFFUSE_CUBE_MAP)) || (defined(LIGHT) && defined(NORMAL_MAP))\n      v_uv = a_uv * u_textureScale;\n    #endif\n\n    #ifdef LIGHT\n      vec3 viewPosition = (u_modelViewMatrix * finalPosition).xyz;\n      v_lightDirection = u_lightPosition - viewPosition;\n      v_eyeDirection = -viewPosition;\n\n      #ifdef NORMAL_MAP\n        mat3 modelViewMatrix3 = mat3(u_modelViewMatrix);\n        vec3 normal = normalize(modelViewMatrix3 * finalNormal);\n        vec3 tangent = normalize(modelViewMatrix3 * finalTangent);\n        vec3 bitangent = cross(normal, tangent);\n        mat3 tbnMatrix = mat3(\n          tangent.x, bitangent.x, normal.x,\n          tangent.y, bitangent.y, normal.y,\n          tangent.z, bitangent.z, normal.z\n        );\n        v_lightDirection = tbnMatrix * v_lightDirection;\n        v_eyeDirection = tbnMatrix * v_eyeDirection;\n      #else\n        v_normalView = u_normalViewMatrix * finalNormal;\n      #endif\n    #else\n      #if defined(ENV_MAP)\n        v_normalView = u_normalViewMatrix * finalNormal;\n      #endif\n    #endif\n\n    #ifdef ENV_MAP\n      v_viewPosition = u_viewMatrix * finalPosition;\n    #endif\n\n    #ifdef VERTEX_COLOR\n      v_color = a_color;\n    #endif\n  #endif\n\n  #ifdef WIREFRAME\n    v_barycentric = a_barycentric;\n  #endif\n\n  #ifdef CLIPPLANE\n    v_position = finalPosition;\n  #endif\n\n  gl_Position = u_modelViewProjectMatrix * finalPosition;\n}\n';
var defaultFragmentShader = '#ifdef VERTEX_COLOR\n  varying vec4 v_color;\n#endif\n\n#ifdef DIFFUSE_MAP\n  #ifdef DIFFUSE_CUBE_MAP\n    uniform samplerCube u_diffuseSampler;\n    varying vec3 v_normal;\n  #else\n    uniform sampler2D u_diffuseSampler;\n  #endif\n#endif\n\nuniform vec4 u_diffuseColor;\n\n#if (defined(DIFFUSE_MAP) && !defined(DIFFUSE_CUBE_MAP)) || (defined(LIGHT) && defined(NORMAL_MAP))\n  varying vec2 v_uv;\n#endif\n\n#if (defined(LIGHT) && !defined(NORMAL_MAP)) || defined(ENV_MAP)\n  varying vec3 v_normalView;\n#endif\n\n#ifdef ENV_MAP\n  uniform mat3 u_modelViewInvMatrix;\n  uniform samplerCube u_envSampler;\n  varying vec4 v_viewPosition;\n#endif\n\n#ifdef LIGHT\n  uniform vec3 u_lightColor;\n  uniform vec3 u_lightAmbientColor;\n  uniform vec4 u_ambientColor;\n  uniform vec4 u_emissiveColor;\n  uniform float u_shininess;\n  varying vec3 v_lightDirection;\n  varying vec3 v_eyeDirection;\n\n  #ifdef AMBIENT_MAP\n    uniform sampler2D u_ambientSampler;\n  #endif\n  #ifdef SPECULAR_MAP\n    uniform sampler2D u_specularSampler;\n  #else\n    uniform vec4 u_specularColor;\n  #endif\n  #ifdef EMISSIVE_MAP\n    uniform sampler2D u_emissiveSampler;\n  #endif\n  #ifdef NORMAL_MAP\n    uniform sampler2D u_normalSampler;\n  #endif\n#endif\n\n#ifdef WIREFRAME\n  uniform vec3 u_wireframeColor;\n  uniform float u_wireframeWidth;\n  varying vec3 v_barycentric;\n\n  float edgeFactor () {\n    vec3 d = fwidth(v_barycentric);\n    vec3 a3 = smoothstep(vec3(0.0), d * u_wireframeWidth, v_barycentric);\n    return min(min(a3.x, a3.y), a3.z);\n  }\n#endif\n\n#ifdef CLIPPLANE\n  uniform vec4 u_clipPlane;\n  varying vec4 v_position;\n#endif\n\nuniform float u_transparency;\n\nvoid main () {\n  #ifdef CLIPPLANE\n    float clipDistance = dot(v_position.xyz, u_clipPlane.xyz);\n    if (clipDistance >= u_clipPlane.w) {\n      discard;\n    }\n  #endif\n\n  #if defined(WIREFRAME) && defined(WIREFRAME_ONLY)\n    gl_FragColor = vec4(u_wireframeColor, (1.0 - edgeFactor()) * u_transparency);\n  #else\n    #ifdef DIFFUSE_MAP\n      #ifdef DIFFUSE_CUBE_MAP\n        vec4 color = textureCube(u_diffuseSampler, v_normal);\n      #else\n        vec4 color = texture2D(u_diffuseSampler, v_uv);\n      #endif\n    #else\n      vec4 color = vec4(1.0);\n    #endif\n\n    #ifdef VERTEX_COLOR\n      color *= v_color;\n    #endif\n\n    #ifdef ENV_MAP\n      vec3 N = v_normalView;\n      vec3 V = v_viewPosition.xyz;\n      vec3 R = reflect(V, N);\n      R = u_modelViewInvMatrix * R;\n      color = textureCube(u_envSampler, R) * color;\n    #endif\n\n    color.a *= u_transparency;\n\n    #ifdef LIGHT\n      #ifdef NORMAL_MAP\n        vec3 normal = normalize((texture2D(u_normalSampler, v_uv) * 2.0 - 1.0).rgb);\n      #else\n        vec3 normal = normalize(v_normalView);\n      #endif\n\n      vec3 lightDirection = normalize(v_lightDirection);\n      vec3 eyeDirection = normalize(v_eyeDirection);\n      float diffuse = max(dot(lightDirection, normal), 0.0);\n\n      vec3 reflectDirection = reflect(-lightDirection, normal);\n      float specular = 0.0;\n      if (u_shininess > 0.0) {\n        specular = pow(max(dot(reflectDirection, eyeDirection), 0.0), u_shininess);\n      }\n\n      #ifdef AMBIENT_MAP\n        vec3 ambientSamplerColor = texture2D(u_ambientSampler, v_uv).rgb;\n      #else\n        vec3 ambientSamplerColor = vec3(1.0);\n      #endif\n\n      #ifdef SPECULAR_MAP\n        vec4 specularMaterialColor = texture2D(u_specularSampler, v_uv);\n      #else\n        vec4 specularMaterialColor = u_specularColor;\n      #endif\n\n      vec4 emissiveColor = u_emissiveColor;\n      #ifdef EMISSIVE_MAP\n        emissiveColor += texture2D(u_emissiveSampler, v_uv);\n      #endif\n\n      vec3 ambientColor = u_lightAmbientColor * u_ambientColor.rgb;\n      vec3 diffuseColor = u_lightColor * u_diffuseColor.rgb * diffuse;\n      vec3 specularColor = u_lightColor * specularMaterialColor.rgb * specular;\n      vec3 finalColor = clamp(ambientColor + diffuseColor + emissiveColor.rgb, 0.0, 1.0);\n      finalColor *= color.rgb * ambientSamplerColor;\n      finalColor += specularColor/* + reflectionColor + refractionColor*/;\n      color = vec4(finalColor, u_diffuseColor.a * color.a);\n    #else\n      color = vec4(u_diffuseColor.rgb * color.rgb, u_diffuseColor.a * color.a);\n    #endif\n    #ifdef WIREFRAME\n      gl_FragColor = mix(vec4(u_wireframeColor, u_transparency), color, edgeFactor());\n    #else\n      gl_FragColor = color;\n    #endif\n  #endif\n}\n';
